<!DOCTYPE html>
<html lang="en" >

<head>

  <meta charset="UTF-8">  
  <title>Autocomplete</title>

<style>
body {
  height: 100%;
  min-height: 800px;
}

html {
  position: relative;
  width: 100%;
  min-height: 800px;
  height: 100%;
}

#app {
  height: 100%;
  margin: 0;
}

.container {
  display: -webkit-box;
  display: flex;
  height: 100%;
  -webkit-box-align: center;
          align-items: center;
  -webkit-box-pack: center;
          justify-content: center;
}

.autocomplete {
  position: relative;
}

.autocomplete-input {
  padding: 7px 10px;
  width: 100%;
  border: 1px solid #ddd;
  outline: none;
}
.autocomplete-input:focus {
  border-color: #b0c4de;
}
.autocomplete-list {
  position: absolute;
  z-index: 2;
  overflow: auto;
  min-width: 250px;
  max-height: 150px;
  margin: 0;
  margin-top: 5px;
  padding: 0;
  border: 1px solid #eee;
  list-style: none;
  border-radius: 4px;
  background-color: #fff;
  box-shadow: 0 5px 25px rgba(0, 0, 0, 0.05);
}
.autocomplete-list li {
  margin: 0;
  padding: 3px 6px;
  border-bottom: 1px solid #f5f5f5;
}
.autocomplete-list li:last-child {
  border-bottom: 0;
}
.autocomplete-list li:hover, .autocomplete-list li.active {
  background-color: #f5f5f5;
}
</style>

</head>

<body translate="no" >
  <script type="text/x-template" id="autocomplete-tpl">
    <div class="autocomplete"> 
      <label :for="id">{{label}}</label>
      <textarea v-if="textarea" :id="id" :rows="rows" :cols="cols" class="autocomplete-input" id="focus-caret"
      @focusout="focusout" @focus="focus" @keydown.13="chooseItem" @keydown.tab="chooseItem"
       @keydown.40="moveDown" @keydown.38="moveUp" @click="selectItem(index)" 
       type="text" ref="input" :value="inputValue"></textarea>
       <!-- <textarea v-if="textarea" :id="id" :rows="rows" :cols="cols" class="autocomplete-input"  
      @focusout="focusout" @focus="focus" @click="selectItem(index)" 
       type="text" ref="input" :value="inputValue"></textarea> -->
        <ul :class="{'autocomplete-list': true,[id+'-list']: true}" v-if="searchMatch.length > 0">
        <li :class="{active: selectedIndex === index}" v-for="(result, index) in searchMatch" 
        @click="selectItem(index), chooseItem()" v-html="highlightWord(result)" ></li>
      <!-- <li :class="{active: selectedIndex === index}" v-for="(result, index) in searchMatch" 
      @click="selectItem(index) chooseItem()" v-html="highlightWord(result)" ></li> -->
        </ul>
    </div>
  </script>


  <div id="app">
    <div class="container">
        <autocomplete label="ãŠãƒ¼ã¨ã“ã‚“ã·ã‚Šãƒ¼ã¨" rows="10" cols="40" textarea="true" />
    </div>
  </div>
  
  <script src='https://cdnjs.cloudflare.com/ajax/libs/vue/2.3.3/vue.js'></script>
  <script src="tiny_segmenter-0.2.js" type="text/javascript"></script>
  <script id="rendered-js">
    
    const yomikataDict = {"ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸ":"æœ‰é›£ã†ã”ã–ã„ã¾ã—ãŸ",
                          "ãŠã›ã‚ã«ãªã£ã¦ãŠã‚Šã¾ã™":"ãŠä¸–è©±ã«ãªã£ã¦ãŠã‚Šã¾ã™",
                          "ã„ã¤ã‚‚ãŠã›ã‚ã«ãªã£ã¦ãŠã‚Šã¾ã™":"ã„ã¤ã‚‚ãŠä¸–è©±ã«ãªã£ã¦ãŠã‚Šã¾ã™",
                          "ãŠã›ã‚ã«ãªã‚Šã¾ã™":"ãŠä¸–è©±ã«ãªã‚Šã¾ã™",
                          "ã•ã£ããã®ãŠã¸ã‚“ã˜ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸ":"æ—©é€Ÿã®ãŠè¿”äº‹ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸ",
                          "ã‚ˆã‚ã—ããŠã­ãŒã„ã„ãŸã—ã¾ã™":"ã‚ˆã‚ã—ããŠé¡˜ã„ã„ãŸã—ã¾ã™",
                          "ãŠã¸ã‚“ã˜ãŠã¾ã¡ã—ã¦ãŠã‚Šã¾ã™":"ãŠè¿”äº‹ãŠå¾…ã¡ã—ã¦ãŠã‚Šã¾ã™",
                          "ãŠã¦ã™ã†ã‚’ãŠã‹ã‘ã—ã¾ã™ãŒ":"ãŠæ‰‹æ•°ã‚’ãŠã‹ã‘ã—ã¾ã™ãŒ",
                          "ã²ãã¤ã¥ãã‚ˆã‚ã—ããŠã­ãŒã„ã„ã„ãŸã—ã¾ã™":"å¼•ãç¶šãã‚ˆã‚ã—ããŠé¡˜ã„ã„ãŸã—ã¾ã™",
                          "ã¾ã™ã¾ã™ã®ã”ã‹ã¤ã‚„ãã‚’ãŠã„ã®ã‚Šã‚‚ã†ã—ã‚ã’ã¾ã™":"ã¾ã™ã¾ã™ã®ã”æ´»èºã‚’ãŠç¥ˆã‚Šç”³ã—ä¸Šã’ã¾ã™",
                          "ã‚‚ã†ã—ã‚ã‘ã”ã–ã„ã¾ã›ã‚“":"ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“",
                          "ã“ã‚“ã”ã¨ã‚‚ã‚ˆã‚ã—ããŠã­ãŒã„ã‚‚ã†ã—ã‚ã’ã¾ã™":"ä»Šå¾Œã¨ã‚‚ã‚ˆã‚ã—ããŠé¡˜ã„ç”³ã—ä¸Šã’ã¾ã™",
                          "ã”ã¶ã•ãŸã—ã¦ãŠã‚Šã¾ã™":"ã”ç„¡æ²™æ±°ã—ã¦ãŠã‚Šã¾ã™",
                          "ã²ãã¤ã¥ãã€ã©ã†ãã‚ˆã‚ã—ããŠã­ãŒã„ã„ãŸã—ã¾ã™":"å¼•ãç¶šãã€ã©ã†ãã‚ˆã‚ã—ããŠé¡˜ã„ã„ãŸã—ã¾ã™",
                        }

    const Autocomplete = Vue.component("autocomplete", {
      template: "#autocomplete-tpl",
      props: ["items", "label", "textarea", "rows", "cols"],
      data() {
        return {
          id: 'input-' + parseInt(Math.random() * 1000),
          // ç¾æ™‚ç‚¹ã§ã¯ä½¿ç”¨ã—ã¦ã„ãªã„ğŸ‘†
          inputValue: "",
          searchMatch: [],
          selectedIndex: 0,
          clickedChooseItem: false,
          wordIndex: 0 };
      },
      mounted() {
        this.$nextTick(() => {
          const $input = this.$refs.input;
          $input.addEventListener('keyup', this.update);
          $input.addEventListener('compositionend', this.update);
        });
      },

      computed: {
        listToSearch() {
          if (typeof this.items !== "undefined" && this.items.length > 0 ) {
            // ã„ã¤ã“ã“ã‚’é€šã£ã¦ã‚‹ï¼Ÿ
            return this.items;
          } else {
            return Object.keys(yomikataDict);
          }
        },
        currentWord() {
          segmenter = new TinySegmenter();
          // this.inputValue:textareaã«å…¥ã£ã¦ã‚‹æ–‡å­—å…¨ã¦ï¼ˆå…¨è§’è‹±å­—ã‚‚ï¼‰
          morphList = segmenter.segment(this.inputValue.replace(/[ï¼¡-ï½š]/gm, '').split(/[ã€‚]/gm)[this.wordIndex]);
          // morphList:Â ["æ¯è¦ª", "ãŒ", "ã€", "ãŠã›"]
          // wordIndex:å¥èª­ç‚¹ã§åŒºåˆ‡ã£ãŸä¸­ã§ã€ä¸€ç•ªå¾Œã‚ã®è¦ç´ 
          wordBeforeConversion = morphList.slice(-1)[0]
          // wordBeforeConversion:"ãŠã›"
          return wordBeforeConversion
        },
        inputSplitted() {
          return this.inputValue.split(/[ã€‚]/gm);
          // ["ã“ã‚“ã«ã¡ã¯", "ãŠä¸–è©±ã«ãªã£ã¦ãŠã‚Šã¾ã™", "ã¯ï½ˆ"]
        } },

        watch: {
          // å¤‰æ›´ã‚’ç›£è¦–ã™ã‚‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£åã‚’è¨˜è¿°?
          // ã¡ã‚ƒã‚“ã¨ã‹ã‚“ã—ã—ã¦ãã‚Œãªã„ãªã‚
          inputValue() {
            console.log("passed")
            this.focus();
            // this.selectedIndex = 0;
            // this.wordIndex = this.inputSplitted.length - 1;
          } 
        },

      methods: {
        update (e) {
          this.inputValue = e.target.value;
          // e.target:autocompleteã®htmlã‚¿ã‚°
          // e.target.value:textareaã®ä¸­èº«å…¨éƒ¨
          this.selectedIndex = 0;
          this.wordIndex = this.inputSplitted.length - 1;
          // wordIndex:å¥èª­ç‚¹ã§åŒºåˆ‡ã£ãŸä¸­ã§ã€ä¸€ç•ªå¾Œã‚ã®è¦ç´ â†keyã‚’æŠ¼ã™ãŸã³ã«æ›´æ–°ã—ã¦ã„ã‚‹ã€‚
        },

        highlightWord(word) {
          // æ§‹é€ ä¸Šã²ã‚‰ãŒãªã—ã‹èªè­˜ã—ã¦ãã‚Œãªã„ã‹ã‚‰highlightã—ã¦ãªã„
          // return word.replace("(" + this.currentWord + ")/g", '<mark>$1</mark>');
          return word
        },
        setWord(word) {
          let currentWords = this.inputValue.split(/[ã€‚]/);
          // ã‚µã‚¸ã‚§ã‚¹ãƒˆã‚’é¸æŠã—ãŸã¨ãã«ã€ã‚µã‚¸ã‚§ã‚¹ãƒˆå‰ã®textareaå†…ã®å…¨ã¦ã‚’å¥èª­ç‚¹ã§åŒºåˆ‡ã£ãŸãƒªã‚¹ãƒˆ
          if (typeof word == "undefined") {
            // this.currentWordãŒundefinedã«å¤‰æ›´ã•ã‚Œã‚‹ã®ã‚’é˜²ã
            word = ""
            }
          currentWords[this.wordIndex] = currentWords[this.wordIndex].replace(/[ï¼¡-ï½š]/gm, '').replace(this.currentWord, word);
          // wordIndexï¼ˆå¥èª­ç‚¹ã§åŒºåˆ‡ã£ãŸä¸­ã§ã€ä¸€ç•ªå¾Œã‚ã®è¦ç´ ï¼‰ã‚’ã‚µã‚¸ã‚§ã‚¹ãƒˆã§é¸æŠã—ãŸãƒ¯ãƒ¼ãƒ‰ã«å¤‰æ›
          this.wordIndex += 1;
          this.inputValue = currentWords.join('ã€‚')
          document.getElementById('focus-caret').focus()
          // æ–‡ç« ãƒªã‚¹ãƒˆã‚’å¥èª­ç‚¹ã§å¥åˆ‡ã‚‹
        },
        moveDown() {
          // IMEã¨ã‹ã®ã‚‚ã¨ã‹ã‚‰ã‚ã‚‹ã‚µã‚¸ã‚§ã‚¹ãƒˆãŒã‚«ãƒ¼ã‚½ãƒ«ã‚­ãƒ¼ã§å‹•ãã®ã§ã€ã‚­ãƒ¼å‹•ä½œãªã—ã§é¸æŠã™ã‚‹æ–¹ãŒã‚ˆã•ãã†
          // if (this.selectedIndex < this.searchMatch.length - 1) {
          //   this.selectedIndex++;
          // }
        },
        moveUp() {
          // ä¸Šã¨åŒæ§˜
          // if (this.selectedIndex !== -1) {
          //   this.selectedIndex--;
          // }
        },
        selectItem(index) {
          // ä¸Šã¨åŒæ§˜
          this.selectedIndex = index;
          this.chooseItem();
        },
        chooseItem() {
          this.clickedChooseItem = true;
          if (this.selectedIndex != -1 && this.searchMatch.length > 0) {
            this.setWord(this.searchMatch[this.selectedIndex]);
            this.selectedIndex = -1;
          }
        },
        focusout(e) {
          setTimeout(() => {
            if (!this.clickedChooseItem) {
              this.searchMatch = [];
              this.selectedIndex = -1;
            }
            this.clickedChooseItem = false;
          }, 100);
        },
        focus() {
          this.searchMatch = [];
          if (this.currentWord.length > 1) {
            // this.currentWord:å¤‰æ›å‰ã®æ–‡å­—
            regexp = new RegExp('^.*' + this.currentWord + '.*$');
            // this.listToSearch:ã‚ˆã¿ãŒãªå…¨ãƒªã‚¹ãƒˆ
            this.searchMatchHiragana = this.listToSearch.filter(hiragana => hiragana.match(regexp))
            // this.searchMatch:ã‚ˆã¿ãŒãªã‚’æ¼¢å­—å…¥ã‚Šã«æˆ»ã™
            this.searchMatch = this.searchMatchHiragana.map(hiragana => yomikataDict[hiragana])
          }
          if (this.searchMatch.length === 1 && this.currentWord === this.searchMatch[0])
          {
            this.searchMatch = [];
          }
        } 
      } 
    });

    new Vue({
      el: "#app" });

  </script>
</body>

</html>